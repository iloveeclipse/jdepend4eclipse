/******************************************************************************* * Copyright (c) 2004 Andrei Loskutov. * All rights reserved. This program and the accompanying materials * are made available under the terms of the BSD License * which accompanies this distribution, and is available at * http://www.opensource.org/licenses/bsd-license.php * Contributor:  Andrei Loskutov - initial API and implementation *******************************************************************************/package de.loskutov.eclipse.jdepend.views;
/*
 * (c) Copyright IBM Corp. 2000, 2002.
 * This file is made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 */import jdepend.framework.JavaPackage;import org.eclipse.swt.SWT;import org.eclipse.swt.events.ControlAdapter;import org.eclipse.swt.events.ControlEvent;import org.eclipse.swt.events.PaintEvent;import org.eclipse.swt.events.PaintListener;import org.eclipse.swt.graphics.Color;import org.eclipse.swt.graphics.GC;import org.eclipse.swt.graphics.Image;import org.eclipse.swt.graphics.Point;import org.eclipse.swt.graphics.Rectangle;import org.eclipse.swt.widgets.Canvas;import org.eclipse.swt.widgets.Display;import org.eclipse.swt.widgets.Shell;import de.loskutov.eclipse.jdepend.JDepend4EclipsePlugin;/** * Manages a simple drawing surface. */
public final class PaintSurface {
    private Canvas paintCanvas;    protected Image image;    private int visibleWidth = 1;    private int visibleHeight = 1;    /*     * <p>     * The GC must be set up as follows     * (it will be returned to this state upon completion of drawing operations)     * <ul>     *   <li>setXORMode(false)     * </ul>     * </p>     */    private GC gc;    private Color foregroundColor, backgroundColor, greenColor, redColor, lgrayColor, dgrayColor;    private Metric [] metrics;    private int diameter = 8;    /**     * Constructs a PaintSurface.     * <p>     * paintCanvas must have SWT.NO_REDRAW_RESIZE and SWT.NO_BACKGROUND styles,     *     and may have SWT.V_SCROLL and/or SWT.H_SCROLL.     * </p>     * @param paintCanvas the Canvas object in which to render     * @param fillColor the color to fill the canvas with initially     */
    public PaintSurface(Canvas paintCanvas, Color fillColor) {        this.paintCanvas = paintCanvas;        /* Set up the drawing surface */        this.backgroundColor = fillColor;        this.foregroundColor = getDisplay().getSystemColor(SWT.COLOR_BLACK);        this.greenColor = getDisplay().getSystemColor(SWT.COLOR_GREEN);        this.redColor = getDisplay().getSystemColor(SWT.COLOR_RED);        this.lgrayColor = getDisplay().getSystemColor(SWT.COLOR_GRAY); // new Color(getDisplay(), 204,204,204);        this.dgrayColor = getDisplay().getSystemColor(SWT.COLOR_DARK_GRAY); // new Color(getDisplay(), 102,102,102);        handleResize();        paintCanvas.addPaintListener(new PaintListener() {            public void paintControl(PaintEvent event) {                event.gc.drawImage(image,                    event.x, event.y, event.width, event.height,                    event.x, event.y, event.width, event.height);            }        });        paintCanvas.addControlListener(new ControlAdapter() {            public void controlResized(ControlEvent event) {                handleResize();            }        });    }    protected Metric getMetric(int x, int y){        if(metrics == null){            return null;        }        // tolerance        int d = diameter*2/3;        int x0 = x-d;        int x1 = x+d;        int y0 = y-d;        int y1 = y+d;        int mx = 0;        int my = 0;        for (int i = 0; i < metrics.length; i++) {            mx = getRelativeToScreenWidth(metrics[i].x);            my = getRelativeToScreenHeight(metrics[i].y);            if(mx >= x0 && mx <= x1                && my >= y0 && my <= y1){                return metrics[i];            }        }        return null;    }    /**     * Draws a Figure object to the screen and to the backing store permanently.     *     *  x   is instability       y is abstractness     */    public void drawMetrics(JavaPackage [] packages ){        if(packages == null){            return;        }        Metric [] myMetrics = new Metric[packages.length];        for (int i = 0; i < packages.length; i++) {            myMetrics[i] = new Metric(packages[i]);        }        this.metrics = myMetrics;        drawMetrics(myMetrics);        paintCanvas.update();        paintCanvas.redraw();    }    private void drawMetrics(Metric [] myMetrics){        if(gc == null){            return;        }        clearScreen();        for (int i = 0; i < myMetrics.length; i++) {            drawMetric(myMetrics[i]);        }        int x, y, x0, y100, x100, y0;        gc.setLineStyle(SWT.LINE_DOT);        gc.setForeground(lgrayColor);        x0 = getRelativeToScreenWidth(0);        x100 = getRelativeToScreenWidth(100);        y0 = getRelativeToScreenHeight(0);        y100 = getRelativeToScreenHeight(100);        // 2 * 9^2 ~= 160 = 40^2        x = getRelativeToScreenWidth(9);        y = getRelativeToScreenHeight(9);        gc.drawLine(x, y100, x100, y);        //2 * 9^2 ~= 160 = 40^2        y = getRelativeToScreenHeight(91);        x = getRelativeToScreenWidth(91);        gc.drawLine(x0, y, x, y0);        gc.setForeground(dgrayColor);        gc.drawLine(x0, y0, x0, y100);        gc.drawLine(x0,y0 - 1, x100, y0 - 1);        gc.setForeground(redColor);        gc.drawString(JDepend4EclipsePlugin.getResourceString("PaintSurface.Instability_arrow"), x0 + 2, y100 - 2*gc.getCharWidth('_') ); //$NON-NLS-1$        //gc.drawString("|", x100 + 2 + gc.getCharWidth('/')/2, y0 - 3*gc.getCharWidth('_') );        gc.drawString("^", x100 + 2, y0 - 5*gc.getCharWidth('_') ); //$NON-NLS-1$        gc.drawString("|", x100 + 2 + gc.getCharWidth('^')/2, y0 - 3*gc.getCharWidth('_') ); //$NON-NLS-1$        //gc.drawString("/\\", x100 + 2, y0 - 5*gc.getCharWidth('_') );        gc.drawString(JDepend4EclipsePlugin.getResourceString("PaintSurface.Abstractness_arrow"), x100 + 2, y0 - 2*gc.getCharWidth('_') ); //$NON-NLS-1$        gc.setForeground(lgrayColor);        gc.drawLine(x100,y100, x0, y100);        gc.drawLine(x100,y100, x100, y0);    }    private void clearScreen(){        gc.setBackground(backgroundColor);        gc.fillRectangle(0,0, visibleWidth, visibleHeight);    }    private void drawMetric(Metric metric){        int radius = diameter/2;        // x, y are between 0 and 100        int x = getRelativeToScreenWidth(metric.x);        int y = getRelativeToScreenHeight(metric.y);        y -= radius;        x -= radius;        int d = metric.z;        Color c;        if(d < 20){            c = greenColor;        } else if(d < 80){            c = foregroundColor;        } else {            c = redColor;        }        gc.setBackground(c);        gc.fillOval(x, y, diameter, diameter);        gc.setBackground(backgroundColor);    }    public int getRelativeToScreenWidth(int x){        int one_x = this.visibleWidth  / 100;        return x * one_x;    }    public int getRelativeToScreenHeight(int y){        int one_y = visibleHeight / 100;        int result = visibleHeight - y * one_y;        return result;    }    /**     * Disposes of the PaintSurface's resources.     */    public void dispose() {        if(image != null){            if(gc != null){                gc.dispose();            }            image.dispose();        }        metrics = null;        paintCanvas = null;        image = null;        foregroundColor = null;        backgroundColor = null;        greenColor = null;        redColor = null;        lgrayColor = null;        dgrayColor = null;    }    /**     * Called when we must grab focus.     */    public void setFocus()  {        paintCanvas.setFocus();    }    /**     * Returns the Display on which the PaintSurface resides.     * @return the Display     */    public Display getDisplay() {        return paintCanvas.getDisplay();    }    /**     * Returns the Shell in which the PaintSurface resides.     * @return the Shell     */    public Shell getShell() {        return paintCanvas.getShell();    }    /**     * Handles resize events     */    protected void handleResize() {        paintCanvas.update();        Point visibleSize = paintCanvas.getSize();        visibleWidth = visibleSize.x;        visibleHeight = visibleSize.y;        Rectangle displayRect = paintCanvas.getDisplay().getClientArea();        int imageWidth = displayRect.width;        int imageHeight = displayRect.height;        if(image != null){            if(gc != null){                gc.dispose();            }            image.dispose();        }        /* Set up the drawing surface */        image = new Image(paintCanvas.getDisplay(), imageWidth, imageHeight);        gc = new GC(image);        gc.setBackground(backgroundColor);        gc.fillRectangle(0, 0, imageWidth, imageHeight);        if(metrics != null && this.gc != null){            drawMetrics(metrics);        }        //paintCanvas.redraw();    }    public static final class Metric {        // instability        public int x;        // abstractness        public int y;        // distance        public int z;        public JavaPackage pack;        public Metric(JavaPackage pack){            this.pack = pack;            x = (int)(pack.instability() * 100);            y = (int)(pack.abstractness() * 100);            z = (int)(pack.distance() * 100);        }        public String toString() {            StringBuffer sb = new StringBuffer();            sb.append(pack.getName());            sb.append('\n').append(JDepend4EclipsePlugin.getResourceString("PaintSurface.instability")).append('\t'); //$NON-NLS-1$            sb.append(x).append('\n').append(JDepend4EclipsePlugin.getResourceString("PaintSurface.abstractness")).append('\t').append(y); //$NON-NLS-1$            sb.append('\n').append(JDepend4EclipsePlugin.getResourceString("PaintSurface.distance")).append('\t').append(z); //$NON-NLS-1$            return sb.toString();        }    }}
